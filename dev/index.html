<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GenomicBreedingIO.jl</title><meta name="title" content="Home · GenomicBreedingIO.jl"/><meta property="og:title" content="Home · GenomicBreedingIO.jl"/><meta property="twitter:title" content="Home · GenomicBreedingIO.jl"/><meta name="description" content="Documentation for GenomicBreedingIO.jl."/><meta property="og:description" content="Documentation for GenomicBreedingIO.jl."/><meta property="twitter:description" content="Documentation for GenomicBreedingIO.jl."/><meta property="og:url" content="https://GenomicBreeding.github.io/GenomicBreedingIO.jl/"/><meta property="twitter:url" content="https://GenomicBreeding.github.io/GenomicBreedingIO.jl/"/><link rel="canonical" href="https://GenomicBreeding.github.io/GenomicBreedingIO.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>GenomicBreedingIO.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="GenomicBreedingIO"><a class="docs-heading-anchor" href="#GenomicBreedingIO">GenomicBreedingIO</a><a id="GenomicBreedingIO-1"></a><a class="docs-heading-anchor-permalink" href="#GenomicBreedingIO" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/jeffersonfparil/GenomicBreedingIO.jl">GenomicBreedingIO</a>.</p><ul><li><a href="#GenomicBreedingIO.isfuzzymatch-Tuple{String, String}"><code>GenomicBreedingIO.isfuzzymatch</code></a></li><li><a href="#GenomicBreedingIO.levenshteindistance-Tuple{String, String}"><code>GenomicBreedingIO.levenshteindistance</code></a></li><li><a href="#GenomicBreedingIO.readdelimited-Tuple{Type{GenomicBreedingCore.Trials}}"><code>GenomicBreedingIO.readdelimited</code></a></li><li><a href="#GenomicBreedingIO.readdelimited-Tuple{Type{GenomicBreedingCore.Phenomes}}"><code>GenomicBreedingIO.readdelimited</code></a></li><li><a href="#GenomicBreedingIO.readdelimited-Tuple{Type{GenomicBreedingCore.Genomes}}"><code>GenomicBreedingIO.readdelimited</code></a></li><li><a href="#GenomicBreedingIO.readjld2-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:GenomicBreedingCore.AbstractGB"><code>GenomicBreedingIO.readjld2</code></a></li><li><a href="#GenomicBreedingIO.readvcf-Tuple{}"><code>GenomicBreedingIO.readvcf</code></a></li><li><a href="#GenomicBreedingIO.vcfchunkify-Tuple{String}"><code>GenomicBreedingIO.vcfchunkify</code></a></li><li><a href="#GenomicBreedingIO.vcfcountlocialleles-Tuple{String}"><code>GenomicBreedingIO.vcfcountlocialleles</code></a></li><li><a href="#GenomicBreedingIO.vcfextractallelefreqs!-Tuple{GenomicBreedingCore.Genomes, Union{Nothing, ProgressMeter.Progress}, Vector{Int64}}"><code>GenomicBreedingIO.vcfextractallelefreqs!</code></a></li><li><a href="#GenomicBreedingIO.vcfextractentriesandformats-Tuple{String}"><code>GenomicBreedingIO.vcfextractentriesandformats</code></a></li><li><a href="#GenomicBreedingIO.vcfextractinfo-Tuple{String}"><code>GenomicBreedingIO.vcfextractinfo</code></a></li><li><a href="#GenomicBreedingIO.vcfinstantiateoutput-Tuple{String}"><code>GenomicBreedingIO.vcfinstantiateoutput</code></a></li><li><a href="#GenomicBreedingIO.vcfparsecoordinates-Tuple{}"><code>GenomicBreedingIO.vcfparsecoordinates</code></a></li><li><a href="#GenomicBreedingIO.writedelimited-Tuple{GenomicBreedingCore.Genomes}"><code>GenomicBreedingIO.writedelimited</code></a></li><li><a href="#GenomicBreedingIO.writedelimited-Tuple{GenomicBreedingCore.Phenomes}"><code>GenomicBreedingIO.writedelimited</code></a></li><li><a href="#GenomicBreedingIO.writedelimited-Tuple{GenomicBreedingCore.Trials}"><code>GenomicBreedingIO.writedelimited</code></a></li><li><a href="#GenomicBreedingIO.writejld2-Tuple{GenomicBreedingCore.AbstractGB}"><code>GenomicBreedingIO.writejld2</code></a></li><li><a href="#GenomicBreedingIO.writevcf-Tuple{GenomicBreedingCore.Genomes}"><code>GenomicBreedingIO.writevcf</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.isfuzzymatch-Tuple{String, String}" href="#GenomicBreedingIO.isfuzzymatch-Tuple{String, String}"><code>GenomicBreedingIO.isfuzzymatch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isfuzzymatch(a::String, b::String; threshold::Float64=0.3)::Bool</code></pre><p>Determines if two strings approximately match each other using Levenshtein distance.</p><p>The function compares two strings and returns <code>true</code> if they are considered similar enough based on the Levenshtein edit distance and a threshold value. The threshold is applied as a fraction of the length of the shorter string.</p><p><strong>Arguments</strong></p><ul><li><code>a::String</code>: First string to compare</li><li><code>b::String</code>: Second string to compare</li><li><code>threshold::Float64=0.3</code>: Maximum allowed edit distance as a fraction of the shorter string length</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the strings match within the threshold, <code>false</code> otherwise</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isfuzzymatch(&quot;populations&quot;, &quot;populations&quot;)
true

julia&gt; isfuzzymatch(&quot;populations&quot;, &quot;poplation&quot;)
true

julia&gt; isfuzzymatch(&quot;populations&quot;, &quot;entry&quot;)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/fuzzy_matching.jl#L56-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.levenshteindistance-Tuple{String, String}" href="#GenomicBreedingIO.levenshteindistance-Tuple{String, String}"><code>GenomicBreedingIO.levenshteindistance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">levenshteindistance(a::String, b::String)::Int64</code></pre><p>Calculate the Levenshtein distance (edit distance) between two strings.</p><p>The Levenshtein distance is a measure of the minimum number of single-character edits  (insertions, deletions, or substitutions) required to change one string into another.</p><p><strong>Arguments</strong></p><ul><li><code>a::String</code>: First input string</li><li><code>b::String</code>: Second input string</li></ul><p><strong>Returns</strong></p><ul><li><code>Int64</code>: The minimum number of edits needed to transform string <code>a</code> into string <code>b</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; levenshteindistance(&quot;populations&quot;, &quot;populations&quot;)
0

julia&gt; levenshteindistance(&quot;populations&quot;, &quot;poplation&quot;)
2

julia&gt; levenshteindistance(&quot;populations&quot;, &quot;entry&quot;)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/fuzzy_matching.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.readdelimited-Tuple{Type{GenomicBreedingCore.Genomes}}" href="#GenomicBreedingIO.readdelimited-Tuple{Type{GenomicBreedingCore.Genomes}}"><code>GenomicBreedingIO.readdelimited</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readdelimited(
    type::Type{Genomes};
    fname::String,
    sep::String = &quot;\t&quot;,
    parse_populations_from_entries::Union{Nothing,Function} = nothing,
    verbose::Bool = false
)::Genomes</code></pre><p>Load genotype data from a delimited text file into a <code>Genomes</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>type::Type{Genomes}</code>: Type parameter (always <code>Genomes</code>)</li><li><code>fname::String</code>: Path to the input file</li><li><code>sep::String</code>: Delimiter character (default: tab)</li><li><code>parse_populations_from_entries::Union{Nothing,Function}</code>: Optional function to extract population names from entry names</li><li><code>verbose::Bool</code>: Whether to show progress bar during loading</li></ul><p><strong>File Format</strong></p><p>The input file should be structured as follows:</p><ul><li>Supported extensions: .tsv, .csv, or .txt</li><li>Comments and headers start with &#39;#&#39;</li><li>Header format (2 lines where the second line is optional):<ol><li>Column names: &quot;chrom,pos,all<em>alleles,allele,entry</em>1,entry_2,...&quot;</li><li>Population names (optional): &quot;chrom,pos,all<em>alleles,allele,pop</em>1,pop_2,...&quot;</li></ol></li><li>Data columns:<ol><li>chromosome identifier</li><li>position (integer)</li><li>all alleles at locus (delimited by &#39;|&#39;)</li><li>specific allele</li></ol>5+. allele frequencies for each entry (0.0-1.0 or missing/NA)</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A populated Genomes struct containing the loaded data</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If file doesn&#39;t exist or has invalid format</li><li><code>ArgumentError</code>: If column names don&#39;t match expected format</li><li><code>OverflowError</code>: If allele frequencies are outside [0,1] range</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GenomicBreedingCore.simulategenomes(n=10, verbose=false);

julia&gt; genomes.entries = [string(genomes.populations[i], &quot;-&quot;, genomes.entries[i]) for i in eachindex(genomes.populations)];

julia&gt; fname = writedelimited(genomes);

julia&gt; genomes_reloaded = readdelimited(Genomes, fname=fname);

julia&gt; genomes == genomes_reloaded
true

julia&gt; fname = writedelimited(genomes, include_population_header=false);

julia&gt; genomes_reloaded = readdelimited(Genomes, fname=fname);

julia&gt; unique(genomes_reloaded.populations) == [&quot;Unknown_population&quot;]
true

julia&gt; genomes_reloaded = readdelimited(Genomes, fname=fname, parse_populations_from_entries=x -&gt; split(x, &quot;-&quot;)[1]);

julia&gt; genomes == genomes_reloaded
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/tsv.jl#L1-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.readdelimited-Tuple{Type{GenomicBreedingCore.Phenomes}}" href="#GenomicBreedingIO.readdelimited-Tuple{Type{GenomicBreedingCore.Phenomes}}"><code>GenomicBreedingIO.readdelimited</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readdelimited(type::Type{Phenomes}; fname::String, sep::String = &quot;\t&quot;, verbose::Bool = false)::Phenomes</code></pre><p>Load phenotypic data from a delimited text file into a <code>Phenomes</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>type::Type{Phenomes}</code>: Type parameter (must be Phenomes)</li><li><code>fname::String</code>: Path to the input file</li><li><code>sep::String</code>: Delimiter character (default: tab &quot;\t&quot;)</li><li><code>verbose::Bool</code>: Whether to show progress bar during loading (default: false)</li></ul><p><strong>File Format</strong></p><p>The file should be a delimited text file with:</p><ul><li>Header row containing column names</li><li>First column: Entry identifiers</li><li>Second column: Population identifiers </li><li>Remaining columns: Phenotypic trait values (numeric or missing)</li></ul><p>Missing values can be specified as &quot;missing&quot;, &quot;NA&quot;, &quot;na&quot;, &quot;N/A&quot;, &quot;n/a&quot; or empty string.</p><p><strong>Returns</strong></p><ul><li><code>Phenomes</code>: A Phenomes struct containing the loaded phenotypic data</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If file doesn&#39;t exist or has invalid format</li><li><code>ArgumentError</code>: If required columns are missing or misnamed</li><li><code>ErrorException</code>: If duplicate entries or traits are found</li><li><code>ErrorException</code>: If numeric values cannot be parsed</li></ul><p><strong>Notes</strong></p><ul><li>Comments starting with &#39;#&#39; are ignored</li><li>Empty lines are skipped</li><li>Mathematical operators (+,-,*,/,%) in trait names are replaced with underscores</li><li>Performs dimension checks on the loaded data</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=10, t=3); phenomes.entries = string.(&quot;entry_&quot;, 1:10); phenomes.populations .= &quot;pop1&quot;; phenomes.traits = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]; phenomes.phenotypes = rand(10,3); phenomes.phenotypes[1,1] = missing; phenomes.mask .= true;

julia&gt; fname = writedelimited(phenomes);

julia&gt; phenomes_reloaded = readdelimited(Phenomes, fname=fname);

julia&gt; phenomes == phenomes_reloaded
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/tsv.jl#L417-L463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.readdelimited-Tuple{Type{GenomicBreedingCore.Trials}}" href="#GenomicBreedingIO.readdelimited-Tuple{Type{GenomicBreedingCore.Trials}}"><code>GenomicBreedingIO.readdelimited</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readdelimited(type::Type{Trials}; fname::String, sep::String = &quot;\t&quot;, verbose::Bool = false)::Trials</code></pre><p>Load a <code>Trials</code> struct from a string-delimited file.</p><p><strong>Arguments</strong></p><ul><li><code>type::Type{Trials}</code>: Type parameter (must be <code>Trials</code>)</li><li><code>fname::String</code>: Path to the input file</li><li><code>sep::String = &quot;\t&quot;</code>: Delimiter character (default is tab)</li><li><code>verbose::Bool = false</code>: Whether to display progress information</li></ul><p><strong>Required File Structure</strong></p><p>The input file must contain the following 10 identifier columns:</p><ul><li><code>years</code>: Year identifiers</li><li><code>seasons</code>: Season identifiers</li><li><code>harvests</code>: Harvest identifiers</li><li><code>sites</code>: Site identifiers</li><li><code>entries</code>: Entry identifiers</li><li><code>populations</code>: Population identifiers</li><li><code>replications</code>: Replication identifiers</li><li><code>blocks</code>: Block identifiers</li><li><code>rows</code>: Row identifiers</li><li><code>cols</code>: Column identifiers</li></ul><p>All remaining columns are treated as numeric phenotype measurements. Column names are fuzzy-matched to accommodate slight spelling variations.</p><p><strong>Returns</strong></p><ul><li><code>Trials</code>: A populated Trials struct containing the loaded data</li></ul><p><strong>Notes</strong></p><ul><li>Missing values can be represented as &quot;missing&quot;, &quot;NA&quot;, &quot;na&quot;, &quot;N/A&quot;, &quot;n/a&quot;, or empty strings</li><li>Trait names containing mathematical operators (+, -, *, /, %) are converted to underscores</li><li>Duplicate trait names are not allowed</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If the input file doesn&#39;t exist or has invalid format</li><li><code>ArgumentError</code>: If required columns are missing or ambiguous</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GenomicBreedingCore.simulategenomes(n=10, verbose=false);

julia&gt; trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, sparsity=0.1, verbose=false);

julia&gt; fname = writedelimited(trials);

julia&gt; trials_reloaded = readdelimited(Trials, fname=fname);

julia&gt; trials == trials_reloaded
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/tsv.jl#L718-L770">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.readjld2-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:GenomicBreedingCore.AbstractGB" href="#GenomicBreedingIO.readjld2-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:GenomicBreedingCore.AbstractGB"><code>GenomicBreedingIO.readjld2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readjld2(type::Type; fname::String)::Type</code></pre><p>Load a core (<code>Genomes</code>, <code>Phenomes</code>, and <code>Trials</code>), simulation (<code>SimulatedEffects</code>), or model (<code>TEBV</code>) struct from a JLD2 file.</p><p><strong>Arguments</strong></p><ul><li><code>type::Type</code>: The type of struct to load (<code>Genomes</code>, <code>Phenomes</code>, <code>Trials</code>, <code>SimulatedEffects</code>, or <code>TEBV</code>)</li><li><code>fname::String</code>: Path to the JLD2 file to read from</li></ul><p><strong>Returns</strong></p><ul><li>The loaded struct of the specified type</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If the specified file does not exist</li><li><code>DimensionMismatch</code>: If the loaded struct is corrupted</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GenomicBreedingCore.simulategenomes(n=2, verbose=false);

julia&gt; fname = writejld2(genomes);

julia&gt; readjld2(Genomes, fname=fname) == genomes
true

julia&gt; phenomes = Phenomes(n=2, t=2); phenomes.entries = [&quot;entry_1&quot;, &quot;entry_2&quot;]; phenomes.traits = [&quot;trait_1&quot;, &quot;trait_2&quot;];

julia&gt; fname = writejld2(phenomes);

julia&gt; readjld2(Phenomes, fname=fname) == phenomes
true

julia&gt; trials, _ = simulatetrials(genomes=genomes, verbose=false);

julia&gt; fname = writejld2(trials);

julia&gt; readjld2(Trials, fname=fname) == trials
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/jld2.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.readvcf-Tuple{}" href="#GenomicBreedingIO.readvcf-Tuple{}"><code>GenomicBreedingIO.readvcf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readvcf(; fname::String, field::String = &quot;any&quot;, min_depth::Int64 = 5, max_depth::Int64 = 100, verbose::Bool = false)::Genomes</code></pre><p>Read genetic data from a VCF (Variant Call Format) file into a Genomes struct.</p><p><strong>Arguments</strong></p><ul><li><code>fname::String</code>: Path to the VCF file. Can be gzipped (.vcf.gz or .vcf.bgz) or uncompressed (.vcf)</li><li><code>field::String=&quot;any&quot;</code>: Which FORMAT field to extract from VCF. Default &quot;any&quot; tries to automatically detect genotype field</li><li><code>min_depth::Int64=5</code>: Minimum read depth threshold for AD (Allele Depth) field</li><li><code>max_depth::Int64=100</code>: Maximum read depth threshold for AD field</li><li><code>verbose::Bool=false</code>: Whether to print progress and debug information</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: A Genomes struct containing the loaded genetic data with fields:<ul><li><code>allele_frequencies</code>: Matrix of allele frequencies</li><li><code>loci_alleles</code>: Vector of locus-allele combination strings</li><li><code>mask</code>: Boolean matrix indicating missing data</li><li><code>samples</code>: Vector of sample names</li></ul></li></ul><p><strong>Details</strong></p><p>Reads VCF files in parallel using multiple threads. Handles multi-allelic variants and different ploidies.  Field priority (when field=&quot;any&quot;):</p><ol><li>AF (Allele Frequency)  </li><li>AD (Allele Depth)  </li><li>GT (Genotype)</li></ol><p>Performs various checks on the input data including:</p><ul><li>File existence</li><li>No duplicate loci-allele combinations </li><li>Consistent dimensions in output struct</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If file doesn&#39;t exist, has duplicates, or output dimensions are invalid</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GenomicBreedingCore.simulategenomes(n=10, verbose=false);

julia&gt; fname = writevcf(genomes);

julia&gt; fname_gz = writevcf(genomes, gzip=true);

julia&gt; genomes_reloaded = readvcf(fname=fname);

julia&gt; genomes_reloaded_gz = readvcf(fname=fname_gz);

julia&gt; genomes.entries == genomes_reloaded.entries == genomes_reloaded_gz.entries
true

julia&gt; dimensions(genomes) == dimensions(genomes_reloaded) == dimensions(genomes_reloaded_gz)
true

julia&gt; ismissing.(genomes.allele_frequencies) == ismissing.(genomes_reloaded.allele_frequencies) == ismissing.(genomes_reloaded_gz.allele_frequencies)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/vcf.jl#L797-L852">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.vcfchunkify-Tuple{String}" href="#GenomicBreedingIO.vcfchunkify-Tuple{String}"><code>GenomicBreedingIO.vcfchunkify</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcfchunkify(fname::String; n_loci::Int64, verbose::Bool = false)::Tuple{Vector{Int64},Vector{Int64},Vector{Int64},Vector{Int64}}</code></pre><p>Divide a VCF file into chunks for parallel processing.</p><p><strong>Arguments</strong></p><ul><li><code>fname::String</code>: Path to the VCF file (can be .vcf, .vcf.gz, or .vcf.bgz)</li><li><code>n_loci::Int64</code>: Total number of loci in the VCF file</li><li><code>verbose::Bool=false</code>: If true, prints progress information</li></ul><p><strong>Returns</strong></p><p>A tuple containing four Vector{Int64} arrays:</p><ol><li>Starting loci indices for each thread</li><li>Ending loci indices for each thread</li><li>Starting file positions for each thread</li><li>Ending file positions for each thread</li></ol><p><strong>Details</strong></p><ul><li>Automatically detects if the input file is gzipped</li><li>Divides the workload evenly across available threads</li><li>Skips header lines (starting with &#39;#&#39;)</li><li>Handles both regular and gzipped VCF files</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GenomicBreedingCore.simulategenomes(n=10, verbose=false);

julia&gt; fname = writevcf(genomes);

julia&gt; _, n_loci, n_alt_alleles = vcfcountlocialleles(fname);

julia&gt; idx_loci_per_thread_ini, idx_loci_per_thread_fin, file_pos_per_thread_ini, file_pos_per_thread_fin = vcfchunkify(fname, n_loci=n_loci);

julia&gt; length(idx_loci_per_thread_ini) == length(idx_loci_per_thread_fin) == length(file_pos_per_thread_ini) == length(file_pos_per_thread_fin)
true

julia&gt; (idx_loci_per_thread_ini[1] == 0) &amp;&amp; (sum(idx_loci_per_thread_ini .== 0) == 1)
true

julia&gt; (idx_loci_per_thread_fin[end] == n_loci) &amp;&amp; (sum(idx_loci_per_thread_fin .== 0) == 0)
true

julia&gt; (sum(file_pos_per_thread_ini .== 0) == 0) &amp;&amp; (sum(file_pos_per_thread_fin .== 0) == 0)
true

julia&gt; rm(fname);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/vcf.jl#L77-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.vcfcountlocialleles-Tuple{String}" href="#GenomicBreedingIO.vcfcountlocialleles-Tuple{String}"><code>GenomicBreedingIO.vcfcountlocialleles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcfcountlocialleles(fname::String; verbose::Bool = false)::Tuple{Int64,Int64}</code></pre><p>Count the number of loci and total lines in a VCF file.</p><p><strong>Arguments</strong></p><ul><li><code>fname::String</code>: Path to the VCF file. Can be either a plain text VCF file or a gzipped VCF file (with extensions .vcf.gz or .vcf.bgz)</li><li><code>verbose::Bool</code>: If true, prints progress messages and results to stdout. Defaults to false.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Int64,Int64}</code>: A tuple containing:<ul><li>First element: Total number of lines in the file (including headers)</li><li>Second element: Number of data lines (variants/loci) excluding header lines</li></ul></li></ul><p><strong>Description</strong></p><p>Reads through a VCF (Variant Call Format) file and counts:</p><ol><li>Total lines in the file (including headers)</li><li>Number of data lines (variants/loci) that don&#39;t start with &#39;#&#39;</li></ol><p>The function automatically detects and handles different file formats:</p><ul><li>Plain text VCF files (.vcf)</li><li>Gzipped VCF files (.vcf.gz)</li><li>BGZipped VCF files (.vcf.bgz)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GenomicBreedingCore.simulategenomes(n=10, verbose=false);

julia&gt; fname = writevcf(genomes);

julia&gt; fname_gz = writevcf(genomes, gzip=true);

julia&gt; n_1, p_1, l_1 = vcfcountlocialleles(fname);

julia&gt; n_2, p_2, l_2 = vcfcountlocialleles(fname_gz);

julia&gt; n_1 == n_2 == 10_009
true

julia&gt; p_1 == p_2 == 10_000
true

julia&gt; l_1 == l_2 == 10_000
true

julia&gt; rm.([fname, fname_gz]);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/vcf.jl#L1-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.vcfextractallelefreqs!-Tuple{GenomicBreedingCore.Genomes, Union{Nothing, ProgressMeter.Progress}, Vector{Int64}}" href="#GenomicBreedingIO.vcfextractallelefreqs!-Tuple{GenomicBreedingCore.Genomes, Union{Nothing, ProgressMeter.Progress}, Vector{Int64}}"><code>GenomicBreedingIO.vcfextractallelefreqs!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcfextractallelefreqs!(genomes::Genomes, pb::Union{Nothing,Progress}, i::Vector{Int64}; 
                      fname::String, line::Vector{String}, line_counter::Int64, 
                      field::String, min_depth::Int64=10, max_depth::Int64=100, 
                      verbose::Bool=false)</code></pre><p>Extract allele frequencies from VCF file data and update a Genomes object.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: Object to store genomic data</li><li><code>pb::Union{Nothing,Progress}</code>: Progress bar object or nothing</li><li><code>i::Vector{Int64}</code>: Single-element vector containing current locus-allele index</li><li><code>fname::String</code>: Name of VCF file being processed</li><li><code>line::Vector{String}</code>: Current line from VCF file split into fields</li><li><code>line_counter::Int64</code>: Current line number in VCF file</li><li><code>field::String</code>: Type of field to extract (&quot;AF&quot;, &quot;AD&quot;, or &quot;GT&quot;)</li><li><code>min_depth::Int64=10</code>: Minimum read depth threshold for AD field</li><li><code>max_depth::Int64=100</code>: Maximum read depth threshold for AD field</li><li><code>verbose::Bool=false</code>: Whether to display progress updates</li></ul><p><strong>Returns</strong></p><p>Nothing; Updates the input parameters in place:</p><ul><li><code>genomes</code>: Updated with new allele frequencies and loci information</li><li><code>pb</code>: Advanced if verbose=true</li><li><code>i</code>: Index incremented based on processed alleles</li></ul><p><strong>Description</strong></p><p>Processes VCF data to extract allele frequencies using one of three methods:</p><ul><li>AF field: Direct frequency values from VCF</li><li>AD field: Calculated from read depths (filtered by min<em>depth and max</em>depth)</li><li>GT field: Calculated from genotype calls</li></ul><p>Updates Genomes object with:</p><ul><li>Loci-allele identifiers (chromosome, position, alleles)</li><li>Allele frequencies for each sample</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If field parameter is not &quot;AF&quot;, &quot;AD&quot;, or &quot;GT&quot;</li><li><code>ErrorException</code>: If unable to parse AF or AD fields from VCF</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GenomicBreedingCore.simulategenomes(n=10, verbose=false);

julia&gt; fname = writevcf(genomes);

julia&gt; _, _, n_alt_alleles = vcfcountlocialleles(fname);

julia&gt; entries, format_lines = vcfextractentriesandformats(fname);

julia&gt; field, n_alleles, _ = vcfextractinfo(fname, format_lines=format_lines);

julia&gt; genomes_instantiated = vcfinstantiateoutput(fname, entries=entries, n_alt_alleles=n_alt_alleles);

julia&gt; sum(ismissing.(genomes_instantiated.allele_frequencies[:, 1])) == length(entries)
true

julia&gt; file = open(fname, &quot;r&quot;); line::Vector{String} = split([readline(file) for i in 1:10][end], &quot;	&quot;); close(file);

julia&gt; vcfextractallelefreqs!(genomes_instantiated, nothing, [0], fname=fname, line=line, line_counter=10, field=field);

julia&gt; sum(ismissing.(genomes_instantiated.allele_frequencies[:, 1])) == 0
true

julia&gt; rm(fname);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/vcf.jl#L612-L678">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.vcfextractentriesandformats-Tuple{String}" href="#GenomicBreedingIO.vcfextractentriesandformats-Tuple{String}"><code>GenomicBreedingIO.vcfextractentriesandformats</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcfextractentriesandformats(fname::String; verbose::Bool = false)::Tuple{Vector{String},Vector{String}}</code></pre><p>Extract sample entries and format definitions from a VCF file.</p><p><strong>Arguments</strong></p><ul><li><code>fname::String</code>: Path to the VCF file (can be gzipped with extensions .vcf.gz or .vcf.bgz)</li><li><code>verbose::Bool=false</code>: If true, prints progress information to stdout</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ol><li><code>Vector{String}</code>: List of sample names from the VCF header</li><li><code>Vector{String}</code>: List of FORMAT field definitions from the VCF metadata</li></ol><p><strong>Description</strong></p><p>Reads a VCF file and extracts two key pieces of information:</p><ol><li>Sample names from the header line (columns after FORMAT field)</li><li>FORMAT field definitions from metadata lines starting with &quot;##FORMAT&quot;</li></ol><p>The function validates the presence and correct order of standard VCF columns: CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO, and FORMAT</p><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If VCF has fewer than expected columns or column names don&#39;t match VCF format</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GenomicBreedingCore.simulategenomes(n=10, verbose=false);

julia&gt; fname = writevcf(genomes);

julia&gt; entries, format_lines = vcfextractentriesandformats(fname);

julia&gt; entries
10-element Vector{String}:
 &quot;entry_01&quot;
 &quot;entry_02&quot;
 &quot;entry_03&quot;
 &quot;entry_04&quot;
 &quot;entry_05&quot;
 &quot;entry_06&quot;
 &quot;entry_07&quot;
 &quot;entry_08&quot;
 &quot;entry_09&quot;
 &quot;entry_10&quot;

julia&gt; format_lines
3-element Vector{String}:
 &quot;##FORMAT=&lt;ID=GT,Number=1,Type=String,Description=\&quot;Genotype\&quot;&gt;&quot;
 &quot;##FORMAT=&lt;ID=AD,Number=2,Type=Float,Description=\&quot;Allele Depth\&quot;&gt;&quot;
 &quot;##FORMAT=&lt;ID=AF,Number=2,Type=Float,Description=\&quot;Allele Frequency\&quot;&gt;&quot;

julia&gt; rm(fname);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/vcf.jl#L180-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.vcfextractinfo-Tuple{String}" href="#GenomicBreedingIO.vcfextractinfo-Tuple{String}"><code>GenomicBreedingIO.vcfextractinfo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcfextractinfo(fname::String; format_lines::Vector{String}, field::String=&quot;any&quot;, verbose::Bool=false)::Tuple{String,Int64,Int64}</code></pre><p>Extract information about genotype fields from a VCF file.</p><p><strong>Arguments</strong></p><ul><li><code>fname::String</code>: Path to the VCF file (can be gzipped)</li><li><code>format_lines::Vector{String}</code>: Vector containing FORMAT lines from the VCF header</li><li><code>field::String=&quot;any&quot;</code>: Specific field to extract (&quot;GT&quot;, &quot;AD&quot;, &quot;AF&quot;, or &quot;any&quot;)</li><li><code>verbose::Bool=false</code>: If true, prints progress information</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ol><li><code>field::String</code>: The identified genotype field</li><li><code>n_alleles::Int64</code>: Maximum number of alleles per locus</li><li><code>ploidy::Int64</code>: Ploidy level (only meaningful for GT field; set to typemax(Int64) for AD and AF fields)</li></ol><p><strong>Details</strong></p><ul><li>If <code>field</code> is &quot;any&quot;, searches for fields in priority order: AF &gt; AD &gt; GT</li><li>For GT field, scans entire file to determine maximum number of alleles and ploidy</li><li>For AF and AD fields, extracts allele count from format header</li><li>Supports both gzipped (.gz, .bgz) and uncompressed VCF files</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If specified field is not found in the VCF file</li><li><code>ErrorException</code>: If unable to parse number of alleles from format header</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GenomicBreedingCore.simulategenomes(n=10, verbose=false);

julia&gt; fname = writevcf(genomes);

julia&gt; _, format_lines = vcfextractentriesandformats(fname);

julia&gt; field, n_alleles, ploidy = vcfextractinfo(fname, format_lines=format_lines);

julia&gt; (field == &quot;AF&quot;) &amp;&amp; (n_alleles == 2) &amp;&amp; (ploidy == typemax(Int64))
true

julia&gt; rm(fname);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/vcf.jl#L306-L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.vcfinstantiateoutput-Tuple{String}" href="#GenomicBreedingIO.vcfinstantiateoutput-Tuple{String}"><code>GenomicBreedingIO.vcfinstantiateoutput</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcfinstantiateoutput(fname::String; entries::Vector{String}, n_alt_alleles::Int64, verbose::Bool = false)::Genomes</code></pre><p>Create and initialize a Genomes struct from VCF file parameters.</p><p><strong>Arguments</strong></p><ul><li><code>fname::String</code>: Name of the VCF file being processed</li><li><code>entries::Vector{String}</code>: Vector containing entry identifiers</li><li><code>n_alt_alleles::Int64</code>: Total number of alternative alleles across all loci</li><li><code>verbose::Bool=false</code>: If true, prints progress information</li></ul><p><strong>Returns</strong></p><ul><li><code>Genomes</code>: An initialized Genomes struct with:<ul><li>dimensions n × p where n is number of entries and p = n<em>alt</em>alleles</li><li>entry names assigned from input entries</li><li>populations set to &quot;unknown&quot;</li><li>mask set to true</li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If duplicate entries are found in the VCF file</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GenomicBreedingCore.simulategenomes(n=10, verbose=false);

julia&gt; fname = writevcf(genomes);

julia&gt; entries, format_lines = vcfextractentriesandformats(fname);

julia&gt; _, _, n_alt_alleles = vcfcountlocialleles(fname);

julia&gt; genomes_instantiated = vcfinstantiateoutput(fname, entries=entries, n_alt_alleles=n_alt_alleles);

julia&gt; size(genomes_instantiated.allele_frequencies)
(10, 10000)

julia&gt; genomes_instantiated.entries == entries
true

julia&gt; rm(fname);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/vcf.jl#L445-L486">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.vcfparsecoordinates-Tuple{}" href="#GenomicBreedingIO.vcfparsecoordinates-Tuple{}"><code>GenomicBreedingIO.vcfparsecoordinates</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vcfparsecoordinates(; line::Vector{String}, line_counter::Int64, field::String)::Union{Nothing,Tuple{Int64,String,Int64,Vector{String}}}</code></pre><p>Parse coordinates and allele information from a VCF file line.</p><p><strong>Arguments</strong></p><ul><li><code>line::Vector{String}</code>: A vector containing the split line from VCF file</li><li><code>line_counter::Int64</code>: Current line number being processed in the VCF file</li><li><code>field::String</code>: The field name to extract allele frequencies from</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code>: If the specified field is not found in the line</li><li><code>Tuple{Int64,String,Int64,Vector{String}}</code>: A tuple containing:<ul><li>Field index</li><li>Chromosome name</li><li>Position</li><li>Combined reference and alternative alleles</li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If the position field cannot be parsed as an integer</li></ul><p><strong>Note</strong></p><p>The function validates the line format and extracts genomic coordinates and allele information from a VCF file line. It handles missing alternative alleles (denoted by &quot;.&quot;) and performs necessary type conversions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GenomicBreedingCore.simulategenomes(n=10, verbose=false);

julia&gt; fname = writevcf(genomes);

julia&gt; entries, format_lines = vcfextractentriesandformats(fname);

julia&gt; field, _, _ = vcfextractinfo(fname, format_lines=format_lines);

julia&gt; file = open(fname, &quot;r&quot;); line::Vector{String} = split([readline(file) for i in 1:10][end], &quot;	&quot;); close(file);

julia&gt; idx_field, chrom, pos, refalts = vcfparsecoordinates(line=line, line_counter=10, field=field);

julia&gt; (idx_field == 3) &amp;&amp; (chrom == line[1]) &amp;&amp; (pos == parse(Int64, line[2])) &amp;&amp; (refalts == line[4:5])
true

julia&gt; rm(fname);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/vcf.jl#L526-L571">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.writedelimited-Tuple{GenomicBreedingCore.Genomes}" href="#GenomicBreedingIO.writedelimited-Tuple{GenomicBreedingCore.Genomes}"><code>GenomicBreedingIO.writedelimited</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writedelimited(
    genomes::Genomes;
    fname::Union{Missing,String} = missing,
    sep::String = &quot;\t&quot;,
    include_population_header::Bool = true
)::String</code></pre><p>Write genomic data to a delimited text file.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A Genomes struct containing the genomic data to be written</li><li><code>fname::Union{Missing,String}</code>: Output filename. If missing, generates an automatic filename with timestamp</li><li><code>sep::String</code>: Delimiter character for the output file (default: tab)</li><li><code>include_population_header::Bool</code>: Whether to include population information in the header (default: true)</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Path to the created output file</li></ul><p><strong>File Format</strong></p><p>The output file contains:</p><ol><li>Header lines (prefixed with &#39;#&#39;):<ul><li>First line: chromosome, position, alleles, and entry information</li><li>Second line (optional): population information</li></ul></li><li>Data rows with the following columns:<ul><li>Column 1: Chromosome identifier</li><li>Column 2: Position</li><li>Column 3: All alleles at the locus (pipe-separated)</li><li>Column 4: Specific allele</li><li>Remaining columns: Frequency data for each entry</li></ul></li></ol><p><strong>Supported File Extensions</strong></p><ul><li>&#39;.tsv&#39; (tab-separated, default)</li><li>&#39;.csv&#39; (comma-separated)</li><li>&#39;.txt&#39; (custom delimiter)</li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code>: If the input Genomes struct is corrupted</li><li><code>ErrorException</code>: If the output file already exists</li><li><code>ArgumentError</code>: If the file extension is invalid or the output directory doesn&#39;t exist</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GenomicBreedingCore.simulategenomes(n=2, verbose=false);

julia&gt; writedelimited(genomes, fname=&quot;test_genomes.tsv&quot;)
&quot;test_genomes.tsv&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/tsv.jl#L310-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.writedelimited-Tuple{GenomicBreedingCore.Phenomes}" href="#GenomicBreedingIO.writedelimited-Tuple{GenomicBreedingCore.Phenomes}"><code>GenomicBreedingIO.writedelimited</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writedelimited(phenomes::Phenomes; fname::Union{Missing,String} = missing, sep::String = &quot;	&quot;)::String</code></pre><p>Write phenotypic data from a <code>Phenomes</code> struct to a delimited text file.</p><p><strong>Arguments</strong></p><ul><li><code>phenomes::Phenomes</code>: A Phenomes struct containing phenotypic data</li><li><code>fname::Union{Missing,String} = missing</code>: Output filename. If missing, generates an automatic filename with timestamp</li><li><code>sep::String = &quot;	&quot;</code>: Delimiter character for the output file</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: The name of the created file</li></ul><p><strong>File Format</strong></p><ul><li>Header line starts with &#39;#&#39; containing column names</li><li>First column: Entry names</li><li>Second column: Population names</li><li>Remaining columns: Trait values</li><li>Missing values are represented as &quot;NA&quot;</li></ul><p><strong>File Extensions</strong></p><p>Supported file extensions:</p><ul><li><code>.tsv</code> for tab-separated files (default)</li><li><code>.csv</code> for comma-separated files</li><li><code>.txt</code> for other delimiters</li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code>: If the Phenomes struct dimensions are inconsistent</li><li><code>ErrorException</code>: If the output file already exists</li><li><code>ArgumentError</code>: If the file extension is invalid or the directory doesn&#39;t exist</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phenomes = Phenomes(n=2, t=2); phenomes.entries = [&quot;entry_1&quot;, &quot;entry_2&quot;]; phenomes.traits = [&quot;trait_1&quot;, &quot;trait_2&quot;];

julia&gt; writedelimited(phenomes, fname=&quot;test_phenomes.tsv&quot;)
&quot;test_phenomes.tsv&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/tsv.jl#L631-L669">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.writedelimited-Tuple{GenomicBreedingCore.Trials}" href="#GenomicBreedingIO.writedelimited-Tuple{GenomicBreedingCore.Trials}"><code>GenomicBreedingIO.writedelimited</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writedelimited(trials::Trials; fname::Union{Missing,String} = missing, sep::String = &quot;	&quot;)::String</code></pre><p>Write a <code>Trials</code> struct to a delimited text file, returning the filename.</p><p><strong>Arguments</strong></p><ul><li><code>trials::Trials</code>: The trials data structure to be written</li><li><code>fname::Union{Missing,String} = missing</code>: Output filename. If missing, generates automatic filename with timestamp</li><li><code>sep::String = &quot;	&quot;</code>: Delimiter character between fields</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: The name of the file that was written</li></ul><p><strong>File Format</strong></p><p>The output file contains one header line and one line per trial entry. Header line is prefixed with &#39;#&#39; and contains column names.</p><p><strong>Fixed Columns (1-10)</strong></p><ol><li>years</li><li>seasons</li><li>harvests</li><li>sites</li><li>entries</li><li>populations</li><li>replications</li><li>blocks</li><li>rows</li><li>cols</li></ol><p><strong>Variable Columns (11+)</strong></p><ul><li>Additional columns contain phenotype traits values</li><li>Missing values are written as &quot;NA&quot;</li></ul><p><strong>Notes</strong></p><ul><li>Supported file extensions: <code>.tsv</code>, <code>.csv</code>, or <code>.txt</code></li><li>File extension is automatically determined based on separator if filename is missing:<ul><li><code>\t</code> → <code>.tsv</code></li><li><code>,</code> or <code>;</code> → <code>.csv</code></li><li>other → <code>.txt</code></li></ul></li><li>Will not overwrite existing files</li><li>Directory must exist if path is specified in filename</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trials = Trials(n=1, t=2); trials.years = [&quot;year_1&quot;]; trials.seasons = [&quot;season_1&quot;]; trials.harvests = [&quot;harvest_1&quot;]; trials.sites = [&quot;site_1&quot;]; trials.entries = [&quot;entry_1&quot;]; trials.populations = [&quot;population_1&quot;]; trials.replications = [&quot;replication_1&quot;]; trials.blocks = [&quot;block_1&quot;]; trials.rows = [&quot;row_1&quot;]; trials.cols = [&quot;col_1&quot;]; trials.traits = [&quot;trait_1&quot;, &quot;trait_2&quot;];

julia&gt; writedelimited(trials, fname=&quot;test_trials.tsv&quot;)
&quot;test_trials.tsv&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/tsv.jl#L931-L980">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.writejld2-Tuple{GenomicBreedingCore.AbstractGB}" href="#GenomicBreedingIO.writejld2-Tuple{GenomicBreedingCore.AbstractGB}"><code>GenomicBreedingIO.writejld2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writejld2(A::Union{Genomes,Phenomes,Trials,SimulatedEffects,TEBV}; fname::Union{Missing,String} = missing)::String</code></pre><p>Save genomic breeding core data structures to a JLD2 file (HDF5-compatible format).</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: A genomic breeding data structure (Genomes, Phenomes, Trials, SimulatedEffects, or TEBV)</li><li><code>fname</code>: Optional. Output filename. If missing, generates an automatic name with timestamp</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Path to the saved JLD2 file</li></ul><p><strong>File Naming</strong></p><ul><li>If <code>fname</code> is not provided, generates name: &quot;output-[Type]-[Timestamp].jld2&quot;</li><li>If <code>fname</code> is provided, must have &quot;.jld2&quot; extension</li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code>: If input structure has invalid dimensions</li><li><code>ErrorException</code>: If output file already exists</li><li><code>ArgumentError</code>: If invalid file extension or directory path</li></ul><p><strong>Notes</strong></p><ul><li>Files are saved with compression enabled</li><li>Data is stored as a Dictionary with single key-value pair</li><li>Key is the string representation of the input type</li><li>Existing files will not be overwritten</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes = GenomicBreedingCore.simulategenomes(n=2, verbose=false);

julia&gt; writejld2(genomes, fname=&quot;test_genomes.jld2&quot;)
&quot;test_genomes.jld2&quot;

julia&gt; genomes_reloaded = load(&quot;test_genomes.jld2&quot;);

julia&gt; genomes_reloaded[collect(keys(genomes_reloaded))[1]] == genomes
true

julia&gt; phenomes = Phenomes(n=2, t=2); phenomes.entries = [&quot;entry_1&quot;, &quot;entry_2&quot;]; phenomes.traits = [&quot;trait_1&quot;, &quot;trait_2&quot;];

julia&gt; writejld2(phenomes, fname=&quot;test_phenomes.jld2&quot;)
&quot;test_phenomes.jld2&quot;

julia&gt; phenomes_reloaded = load(&quot;test_phenomes.jld2&quot;);

julia&gt; phenomes_reloaded[collect(keys(phenomes_reloaded))[1]] == phenomes
true

julia&gt; trials, _ = simulatetrials(genomes=genomes, verbose=false);

julia&gt; writejld2(trials, fname=&quot;test_trials.jld2&quot;)
&quot;test_trials.jld2&quot;

julia&gt; trials_reloaded = load(&quot;test_trials.jld2&quot;);

julia&gt; trials_reloaded[collect(keys(trials_reloaded))[1]] == trials
true

julia&gt; simulated_effects = SimulatedEffects();

julia&gt; writejld2(simulated_effects, fname=&quot;test_simulated_effects.jld2&quot;)
&quot;test_simulated_effects.jld2&quot;

julia&gt; simulated_effects_reloaded = load(&quot;test_simulated_effects.jld2&quot;);

julia&gt; simulated_effects_reloaded[collect(keys(simulated_effects_reloaded))[1]] == simulated_effects
true

julia&gt; trials, _simulated_effects = GenomicBreedingCore.simulatetrials(genomes = GenomicBreedingCore.simulategenomes(n=10, verbose=false), n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=10, verbose=false);

julia&gt; tebv = analyse(trials, max_levels=50, verbose=false);

julia&gt; writejld2(tebv, fname=&quot;test_tebv.jld2&quot;)
&quot;test_tebv.jld2&quot;

julia&gt; tebv_reloaded = load(&quot;test_tebv.jld2&quot;);

julia&gt; tebv_reloaded[collect(keys(tebv_reloaded))[1]] == tebv
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/jld2.jl#L54-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GenomicBreedingIO.writevcf-Tuple{GenomicBreedingCore.Genomes}" href="#GenomicBreedingIO.writevcf-Tuple{GenomicBreedingCore.Genomes}"><code>GenomicBreedingIO.writevcf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writevcf(genomes::Genomes; fname::Union{Missing,String} = missing, ploidy::Int64 = 0, 
         max_depth::Int64 = 100, n_decimal_places::Int64 = 4, gzip::Bool = false)::String</code></pre><p>Write genomic data to a Variant Call Format (VCF) file.</p><p><strong>Arguments</strong></p><ul><li><code>genomes::Genomes</code>: A Genomes object containing the genetic data to be written.</li><li><code>fname::Union{Missing,String} = missing</code>: Output filename. If missing, generates a default name with timestamp.</li><li><code>ploidy::Int64 = 0</code>: The ploidy level of the organisms (e.g., 2 for diploid).</li><li><code>max_depth::Int64 = 100</code>: Maximum depth for allele depth calculation.</li><li><code>n_decimal_places::Int64 = 4</code>: Number of decimal places for rounding allele frequencies.</li><li><code>gzip::Bool = false</code>: Whether to compress the output file using gzip.</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: The name of the created VCF file.</li></ul><p><strong>Description</strong></p><p>Creates a VCF v4.2 format file containing genomic variants data. The function processes allele frequencies and depths, calculates genotypes based on ploidy, and formats the data according to VCF specifications. The output includes:</p><ul><li>Standard VCF header information</li><li>Sample information with FORMAT fields:<ul><li>GT (Genotype)</li><li>AD (Allele Depth)</li><li>AF (Allele Frequency)</li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code>: If the input Genomes object has inconsistent dimensions</li><li><code>ErrorException</code>: If the output file already exists</li><li><code>ArgumentError</code>: If the file extension is not &#39;.vcf&#39; or if the specified directory doesn&#39;t exist</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; genomes_1 = GenomicBreedingCore.simulategenomes(n=2, verbose=false);

julia&gt; writevcf(genomes_1, fname=&quot;test_genomes_1.vcf&quot;)
&quot;test_genomes_1.vcf&quot;

julia&gt; genomes_2 = GenomicBreedingCore.simulategenomes(n=2, n_alleles=3, verbose=false);

julia&gt; genomes_2.allele_frequencies = round.(genomes_2.allele_frequencies .* 4) ./ 4;

julia&gt; writevcf(genomes_2, fname=&quot;test_genomes_2.vcf&quot;, ploidy=4)
&quot;test_genomes_2.vcf&quot;

julia&gt; genomes_3 = GenomicBreedingCore.simulategenomes(n=3, verbose=false);

julia&gt; writevcf(genomes_3, fname=&quot;test_genomes_3.vcf&quot;, gzip=true)
&quot;test_genomes_3.vcf.gz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GenomicBreeding/GenomicBreedingIO.jl/blob/5f723c932176bffedc46492879a27e3b78629fbf/src/vcf.jl#L988-L1039">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Monday 28 April 2025 01:39">Monday 28 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
